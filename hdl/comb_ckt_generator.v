//============================================================================
// comb_ckt_generator.v
//
// This code is generated by Terasic System Builder
// and modified by M. Hildebrand and B. Baas
//
// 2018/02/05 First version
// 2018/04/24 Routed all board-level switches and LEDs to and from this module
//============================================================================

module comb_ckt_generator (
   // VGA-related signals
   vga_clk,
	v_sync,
	col,
   row,
   red,
   green,
   blue,
   // input push buttons and switches
   KEY,
   SW,
   // output LEDs and 7-segment displays
   LEDR,
   HEX0,
   HEX1,
   HEX2,
   HEX3,
   HEX4,
   HEX5
   );

input vga_clk;
input v_sync;
input  [9:0]  col;
input  [8:0]  row;
output [3:0]  red;    // 4-bit color output
output [3:0]  green;  // 4-bit color output
output [3:0]  blue;   // 4-bit color output

// input push buttons and switches
input  [1:0]  KEY;    // two board-level push buttons KEY1 - KEY0
input  [9:0]  SW;     // ten board-level switches SW9 - SW0

// output LEDs and 7-segment displays
output [9:0]  LEDR;   // ten board-level LEDs LEDR9 - LEDR0
output [7:0]  HEX0;   // board-level 7-segment display
output [7:0]  HEX1;   // board-level 7-segment display
output [7:0]  HEX2;   // board-level 7-segment display
output [7:0]  HEX3;   // board-level 7-segment display
output [7:0]  HEX4;   // board-level 7-segment display
output [7:0]  HEX5;   // board-level 7-segment display


//============================================================================
//  reg/wire declarations
//============================================================================
// More complex implementations will likely declare RGB outputs as regs
// rather than wires
reg [3:0]    red, green, blue;    


//============================================================================
// Board-LED related circuits
//============================================================================

// Temporary simple logic
// The 10 LEDs will light depending on the position of the adjacent 10 switches
assign LEDR = SW;      // ten LEDs assigned to ten switches

// Temporary simple logic
// This block sets the 7-segment HEX displays
// HEX4 - HEX0 are set to all dark
// HEX5 lights segments based on SW9 - SW2
assign HEX0 = 8'b1111_1111;
assign HEX1 = 8'b1111_1111;
assign HEX2 = 8'b1111_1111;
assign HEX3 = 8'b1111_1111;
assign HEX4 = 8'b1111_1111;
assign HEX5 = ~{SW[9], SW[8], SW[7], SW[6], SW[5], SW[4], SW[3], SW[2]};


//============ Start of my unique code

reg [9:0] SW_sync;

always @(posedge v_sync) begin

	SW_sync <= #1 SW;

end

wire [11:0] rdAddr; // ROM read address
wire [3:0] rom0OutR, rom0OutG, rom0OutB, rom1OutR, rom1OutG, rom1OutB, rom2OutR, rom2OutG, rom2OutB, rom3OutR, rom3OutG, rom3OutB; // specifying different ROM module outputs
wire addrValid;
reg [1:0] romN;

reg [3:0] rIn, gIn, bIn;
reg [3:0] color_select_inR, color_select_inG, color_select_inB;
wire [3:0] color_select_outR, color_select_outG, color_select_outB;
reg [3:0] grayscale_mult_inR, grayscale_mult_inG, grayscale_mult_inB;
wire [9:0] grayscale_mult_outR, grayscale_mult_outG, grayscale_mult_outB;
reg [9:0] grayscale_add_round_inR, grayscale_add_round_inG, grayscale_add_round_inB;
wire [3:0] grayscale_add_round_out;

reg [3:0] red_c, green_c, blue_c;


address_converter inst_0 (.romN(romN), .row(row), .col(col), .magSwitch(SW_sync[9:8]), .addr(rdAddr), .addrValid(addrValid));

rom_0_r inst_1 (.clock(vga_clk), .address(rdAddr), .data_out(rom0OutR));
rom_0_g inst_2 (.clock(vga_clk), .address(rdAddr), .data_out(rom0OutG));
rom_0_b inst_3 (.clock(vga_clk), .address(rdAddr), .data_out(rom0OutB));

rom_1_r inst_4 (.clock(vga_clk), .address(rdAddr), .data_out(rom1OutR));
rom_1_g inst_5 (.clock(vga_clk), .address(rdAddr), .data_out(rom1OutG));
rom_1_b inst_6 (.clock(vga_clk), .address(rdAddr), .data_out(rom1OutB));

rom_2_r inst_7 (.clock(vga_clk), .address(rdAddr), .data_out(rom2OutR));
rom_2_g inst_8 (.clock(vga_clk), .address(rdAddr), .data_out(rom2OutG));
rom_2_b inst_9 (.clock(vga_clk), .address(rdAddr), .data_out(rom2OutB));

rom_3_r inst_10 (.clock(vga_clk), .address(rdAddr), .data_out(rom3OutR));
rom_3_g inst_11 (.clock(vga_clk), .address(rdAddr), .data_out(rom3OutG));
rom_3_b inst_12 (.clock(vga_clk), .address(rdAddr), .data_out(rom3OutB));

color_select inst_13 (.colorRemove(SW_sync[7:5]), .rIn(color_select_inR), .gIn(color_select_inG), .bIn(color_select_inB), .rOut(color_select_outR), .gOut(color_select_outG), .bOut(color_select_outB));

grayscale_mult inst_14 (.rIn(grayscale_mult_inR), .gIn(grayscale_mult_inG), .bIn(grayscale_mult_inB), .rOut(grayscale_mult_outR), .gOut(grayscale_mult_outG), .bOut(grayscale_mult_outB));

grayscale_add_round inst_15 (.rIn(grayscale_add_round_inR), .gIn(grayscale_add_round_inG), .bIn(grayscale_add_round_inB), .lumaOut(grayscale_add_round_out));

always @(vga_clk) begin

	if (row <= 9'b000100000 * ({1'b0, SW_sync[9:8]} + 3'b001) - 9'b000000001) begin // rom0
	
		romN = 2'b00;
		rIn = rom0OutR;
		gIn = rom0OutG;
		bIn = rom0OutB;
	
	end
	
	else if (row <= 9'b001000000 * ({1'b0, SW_sync[9:8]} + 3'b001) - 9'b000000001) begin // rom1
	
		romN = 2'b01;
		rIn = rom1OutR;
		gIn = rom1OutG;
		bIn = rom1OutB;
	
	end
	
	else if (row <= 9'b001100000 * ({1'b0, SW_sync[9:8]} + 3'b001) - 9'b000000001) begin // rom2
	
		romN = 2'b10;
		rIn = rom2OutR;
		gIn = rom2OutG;
		bIn = rom2OutB;
	
	end
	
	else if (row <= 9'b010000000 * ({1'b0, SW_sync[9:8]} + 3'b001) - 9'b000000001) begin // rom3
	
		romN = 2'b11;
		rIn = rom3OutR;
		gIn = rom3OutG;
		bIn = rom3OutB;
	
	end

end

always @(posedge vga_clk) begin

	if (rIn != color_select_inR || gIn != color_select_inG || bIn != color_select_inB) begin
	
		color_select_inR <= #1 rIn;
		color_select_inG <= #1 gIn;
		color_select_inB <= #1 bIn;
	
	end
	
	if (color_select_outR != grayscale_mult_inR || color_select_outG != grayscale_mult_inG || color_select_outB != grayscale_mult_inB) begin
	
		grayscale_mult_inR <= #1 color_select_outR;
		grayscale_mult_inG <= #1 color_select_outG;
		grayscale_mult_inB <= #1 color_select_outB;
	
	end
	
	if (grayscale_mult_outR != grayscale_add_round_inR || grayscale_mult_outG != grayscale_add_round_inG || grayscale_mult_outB != grayscale_add_round_inB) begin
	
		grayscale_add_round_inR <= #1 grayscale_mult_outR;
		grayscale_add_round_inG <= #1 grayscale_mult_outG;
		grayscale_add_round_inB <= #1 grayscale_mult_outB;
	
	end
	
	red <= #1 red_c;
	green <= #1 green_c;
	blue <= #1 blue_c;

end

always @(vga_clk) begin

	if (addrValid == 1'b0) begin

		red_c = 4'b0000;
		green_c = 4'b0000;
		blue_c = 4'b0000;
		
	end

	else if (SW_sync[7:4] == 4'b0000) begin

		red_c = rIn;
		green_c = gIn;
		blue_c = bIn;

	end

	else if (SW_sync[4] == 1'b0) begin

		red_c = color_select_outR;
		green_c = color_select_outG;
		blue_c = color_select_outB;

	end

	else begin

		red_c = grayscale_add_round_out;
		green_c = grayscale_add_round_out;
		blue_c = grayscale_add_round_out;

	end
	
end

endmodule
